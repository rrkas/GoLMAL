# (GoL)ang based (MA)chine (L)earning (GoLMAL)

- [**Detailed Structure**](./detailed.md)

## Why GoLang? (and not Python)

1. **Compiled vs Interpreted**: Go is compiled to machine code → much faster execution compared to Python’s interpreted runtime.
1. **Concurrency**: Go has built-in lightweight goroutines and channels, making it extremely efficient for parallel/concurrent workloads, unlike Python which suffers from the GIL (Global Interpreter Lock).
1. **Single Binary**: Go compiles into a single self-contained binary with no external dependencies → easy to ship, especially for microservices, CLIs, and cloud tools.
1. **Cross-Compilation**: Native support for cross-compiling to different OS/architectures
1. **Static Typing**: Strong static type system catches errors at compile time, reducing runtime bugs common in Python.
1. **Garbage Collection**: Efficient and modern GC built for low-latency server applications.
1. **First-Class Concurrency**: Goroutines are far lighter than OS threads (can scale to millions).
1. **Network Programming**: Go’s standard library is robust for building APIs, servers, and distributed systems.
1. **Standard Library**: Very rich, covers most needs without external dependencies.
1. **Fast Compilation**: Even large projects compile very quickly compared to C++/Java.
1. **Simplicity**: Go’s syntax is minimal and opinionated, enforcing consistent code across teams.
1. **No Hidden Magic**: Unlike Python, Go avoids runtime hacks/metaprogramming that can hurt readability.
1. Widely adopted in cloud-native ecosystem (Docker, Kubernetes, Terraform, etc. are written in Go).
1. Excellent for DevOps, infrastructure, and distributed systems.


## Features

[ ] GPU (NVIDIA CUDA/ Intel)  

